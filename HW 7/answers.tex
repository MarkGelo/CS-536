% https://github.com/jdavis/latex-homework-template
% https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols

\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts} % for "\mathbb" macro
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usetikzlibrary{automata,positioning}
\newcommand{\indentitem}{\setlength\itemindent{25pt}}
%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClassID\ \hmwkTitle}
\rhead{} % blank, to remove the latest section in page
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

\setcounter{secnumdepth}{0}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Homework\ \#7}
\newcommand{\hmwkDueDate}{April 28, 2022}
\newcommand{\hmwkClass}{Science of Programming}
\newcommand{\hmwkClassID}{CS 536}
\newcommand{\hmwkClassInstructor}{Stefan Muller}
\newcommand{\hmwkAuthorName}{\textbf{Mark Gameng}}

%
% Title Page
%

\author{\hmwkAuthorName}
\date{}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\newcommand{\answer}{\item[]} %new code

\begin{document}
	
	%\maketitle
	
	\section{Task 1.1}
	
		\begin{enumerate}[label={(\alph*)}]
			
			\answer
			\begin{tabular}{c c c c c}
				i & j & Change(i) & Vars(j) & i intf w j \\
				s1 & s2 & $r1, i1$ & $n, r2, i2$ & no \\
				s2 & s1 & $r2, i2$ & $n, r1, i1$ & no \\ 
			\end{tabular}
			
		\end{enumerate}
	
	\section{Task 1.2}
	
		\begin{enumerate}[label={(\alph*)}]
			
			\answer
			$\begin{aligned}[t]
				&\qquad \qquad \qquad \qquad &\{n \geq 0\} \\
				&i1 := 0; \\
				&r1 := 0; &\{n \geq 0 \land i1 = 0 \land r1 = 0\} \\
				&\{\textbf{inv } r1 = sum(0, i1) \land i1 \leq n / 2 \} \\
				&\text{while } (i1 < n / 2) \{ \\
				&\quad r1 := r1 + 1; \\
				&\quad i1 := i1 + 1; \\
				&\} &\{r1 = sum(0, n/2)\} \\
				&i2 := n / 2; \\
				&r2 := 0; &\{r1 = sum(0, n/2) \land i2 = n / 2 \land r2 = 0\} \\
				&\{\textbf{inv } r1 = sum(0, n/2) \land r2 = sum(n / 2, i2) \land i2 \leq n\} \\
				&\text{while } (i2 < n) \{ \\
				&\quad r2 := r2 + i2; \\
				&\quad i2 := i2 + 1; \\
				&\} &\{r1 = sum(0, n/2) \land r2 = sum(n/2, n)\} \\
				& &\Rightarrow \{r1 + r2 = sum(0, n)\} \\
				&r := r1 + r2; \\
				& &\{r = sum(0, n)\} \\
			\end{aligned}$
			
		\end{enumerate}

	\section{Task 1.3}
	
		\begin{enumerate}[label={(\alph*)}]
			
			\answer
			$\begin{aligned}[t]
				&\qquad \qquad \qquad \qquad &\{n \geq 0\} \\
				&[ &\{p_{1} \equiv n \geq 0\} \\
				&i1 := 0; \\
				&r1 := 0; \\
				&\{\textbf{inv } r1 = sum(0, i1) \land i1 \leq n / 2\} \\
				&\text{while }(i1 < n / 2) \{ \\
				&\quad r1 := r1 + i1; \\
				&\quad i1 := i1 + 1; \\ 
				&\} &\{q_{1} \equiv r1 = sum(0, n / 2)\} \\
				&|| &\{p_{2} \equiv n \geq 0\} \\ 
				&i2 := n / 2; \\
				&r2 := 0; \\
				&\{\textbf{inv } r2 = sum(n / 2, i2) \land i2 \leq n\} \\
				&\text{while } (i2 < n) \{ \\
				&\quad r2 := r2 + i2; \\
				&\quad i2 := i2 + 1; \\
				&\} &\{q_{2} \equiv r2 = sum(n / 2, n)\} \\
				&] &\{q_{1} \land q_{2}\} \Rightarrow \{r1 + r2 = sum(0, n)\} \\
				&r := r1 + r2 \\
				& &\{r = sum(0, n)\}
			\end{aligned}$
		
			\begin{tabular}{c c c c c c c}
				i & j & Change(i) & Vars(j) & FV(j) & i intf w j & i intf w cond j \\
				s1 & s2 & $r1, i1$ & $n, r2, i2$ & $r2, n$ & no & no \\
				s2 & s1 & $r2, i2$ & $n, r1, i1$ & $r1, n$ & no & no \\ 
			\end{tabular}
			
		\end{enumerate}
	
	\pagebreak
	
	\section{Task 2.1}
		\begin{enumerate}[label = {(\alph*)}]
			
			\answer
			$\begin{aligned}[t]
				&\qquad \qquad \qquad \qquad &\{n \geq 0 \land i1 = 0 \land r1 = 0\} \\
				&[ &\{n / 2 \leq i2 \leq n \land i1 = 0 \land r2 = sum(n / 2, i2) \land r1 = 0\}\\
				&\{\textbf{inv } i1 \leq n / 2 \land n / 2 \leq i2 \leq n \land r2 = sum(n / 2, i2)\} \\
				&\text{while }(i1 < n / 2) \{ \\
				&\quad < r1 := r1 + i1; \\
				&\quad i1 := i1 + 1; > \\
				&\} &\{r1 = sum(0, n / 2)\} \\
				&|| &\{0 \leq i1 \leq n / 2 \land i2 = n / 2 \land r1 = sum(0, i1) \land r2 = 0\} \\
				&\{\textbf{inv } i2 \leq n \land i1 \leq n / 2 \land r1 = sum(0, i1)\} \\
				&\text{while }(i2 < n) \{ \\
				&\quad r2 := r2 + i2; \\
				&\quad i2 := i2 + 1; \\
				&\} &\{r2 = sum(n / 2, n)\} \\
				&\{\textbf{inv } i1 \leq n / 2 \land r1 = sum(0, i1) \land r2 = sum(n / 2, n)\} \\
				&\text{while } i1 < n / 2 \{skip\} &\{r1 = sum(0, n / 2) \land r2 = sum(n / 2, n)\} \\
				& &\Rightarrow \{r1 + r2 = sum(0, n)\} \\
				&r := r1 + r2 \\
				&] \\
				& &\{r = sum(0, n)\}
 			\end{aligned}$
			
		\end{enumerate}
	
	\pagebreak
	
	\section{Task 2.2}
		\begin{enumerate}[label = {(\alph*)}]
			
			\answer These two proof outlines are interference-free because one thread doesn't invalidate any condition needed by the other thread. Every atomic statement $\{r\} <s> \{...\}$ in $s_{1}^{*}$ doesn't interfere with the proof outline $\{p2\}\; s_{2}^{*} \;\{q2\}$. So, the proof outline $\{p1\}\; s_{1}^{*} \;\{q1\}$ does not interfere with the other proof outline $\{p2\}\; s_{2}^{*} \;\{q2\}$.
			
		\end{enumerate}
	
	\section{Task 3.1}
		\begin{enumerate}[label = {(\alph*)}]
			
			\answer Instead of \{while $(i1 < n / 2) \{skip\}; \; r := r1 + r2$\}, I just use \{await $i1 = n / 2$ then $r := r1 + r2$\}
			
		\end{enumerate}
	
	\section{Task 3.2}
		\begin{enumerate}[label = {(\alph*)}]
			
			\answer It's preferable to use await instead of a loop because the loop is wasteful. While it does work, it repeatedly checks to see if the condition is true. With await, once it checks the condition and it's false, it gets blocked, and waits until the condition is true. So, other threads are run nondeterministically and only goes back to the thread with the await if the condition becomes true.
			
		\end{enumerate}
	
	\section{Task 4.1}
		\begin{enumerate}[label = {(\alph*)}]
			
			\item The problem is that, the "wait" in thread 2, is no longer doing what it's intended. It no longer waits for the other thread, thread 1, to run and finish because it already satisfies the condition even before running thread 1. If thread 2 starts from the beginning, it can finish the whole thing because of the invalid initial conditions in the precondition as well as the initial state $\sigma$. So, with the given $\sigma$, we get $r = r1 + r2 = 523752 + sum(18, 26)$, just from running and finishing thread 2. It then goes to thread 1, and finally gives the correct value, $r1 = sum(0, n / 2)$, however that's all thread 1 does. So, we end in a state where $r \neq sum(0, 26)$.
			
			\item Expected number of times to find the bug in testing is $(1.3 * 10^{14}) / 78 \approx 1.66 * 10^{12}$. This means, if you run the program $1.6$ trillion times you are expected to encounter one buggy execution path. Having a script running 1000 times per second, it will still take you $1.66$ billion seconds, or $19,290$ days, or $52.85$ years to find the bug.
			
			\item $(1.66 * 10^{12}) / (10^{11}) \approx 16.66$ days. It is expected to take about $17$ days for a user to discover the bug. 
			
			\item Testing is not the best way make sure a program does what it's intended and doesn't have any bugs, as indicated by the above answers. It can take days, months, or even more for testing to find a bug. By the time your tests find the bug, or enough users finds and reports the bug, it will already have been too late and the damage has been done. For a mission critical system, testing is not enough and program verification is a must. As such, it is a good thing that I took CS 536 and learned about program verification.
			
		\end{enumerate}
	
	\section{Task 5}
		\begin{enumerate}[label = {(\alph*)}]
			
			\answer I spent about 5 hours on this.
			
		\end{enumerate}
\end{document}
